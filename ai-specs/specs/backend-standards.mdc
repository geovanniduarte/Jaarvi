---
description: Backend development standards, best practices, and conventions for the LTI Node.js/TypeScript/Express application including Domain-Driven Design, SOLID principles, architecture patterns, API design, and testing practices
globs: ["backend/src/**/*.ts", "backend/prisma/**/*.{prisma,ts}", "backend/jest.config.js", "backend/tsconfig.json", "backend/serverless.yml", "backend/package.json"]
alwaysApply: true
---

# Backend Project Standards and Best Practices

## Table of Contents

- [Overview](#overview)
- [Technology Stack](#technology-stack)
  - [Core Technologies](#core-technologies)
  - [Database & ORM](#database--orm)
  - [Testing Framework](#testing-framework)
  - [Development Tools](#development-tools)
- [Architecture Overview](#architecture-overview)
  - [Domain-Driven Design (DDD)](#domain-driven-design-ddd)
  - [Layered Architecture](#layered-architecture)
  - [Project Structure](#project-structure)
- [Domain-Driven Design Principles](#domain-driven-design-principles)
  - [Entities](#entities)
  - [Value Objects](#value-objects)
  - [Aggregates](#aggregates)
  - [Repositories](#repositories)
  - [Domain Services](#domain-services)
  - [Additional Recommendations](#additional-recommendations)
- [SOLID and DRY Principles](#solid-and-dry-principles)
  - [Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)
  - [Open/Closed Principle (OCP)](#openclosed-principle-ocp)
  - [Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)
  - [Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)
  - [Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)
  - [DRY (Don't Repeat Yourself)](#dry-dont-repeat-yourself)
- [Coding Standards](#coding-standards)
  - [Language and Naming Conventions](#language-and-naming-conventions)
  - [TypeScript Usage](#typescript-usage)
  - [Error Handling](#error-handling)
  - [Validation Patterns](#validation-patterns)
  - [Logging Standards](#logging-standards)
- [API Design Standards](#api-design-standards)
  - [REST Endpoints](#rest-endpoints)
  - [Request/Response Patterns](#requestresponse-patterns)
  - [Error Response Format](#error-response-format)
  - [CORS Configuration](#cors-configuration)
- [Database Patterns](#database-patterns)
  - [Prisma Schema](#prisma-schema)
  - [Migrations](#migrations)
  - [Repository Pattern](#repository-pattern)
- [Testing Standards](#testing-standards)
  - [Unit Testing](#unit-testing)
  - [Integration Testing](#integration-testing)
  - [Test Coverage Requirements](#test-coverage-requirements)
  - [Mocking Standards](#mocking-standards)
- [Performance Best Practices](#performance-best-practices)
  - [Database Query Optimization](#database-query-optimization)
  - [Async/Await Patterns](#asyncawait-patterns)
  - [Error Handling Performance](#error-handling-performance)
- [Security Best Practices](#security-best-practices)
  - [Input Validation](#input-validation)
  - [Environment Variables](#environment-variables)
  - [Dependency Injection](#dependency-injection)
- [Development Workflow](#development-workflow)
  - [Git Workflow](#git-workflow)
  - [Development Scripts](#development-scripts)
  - [Code Quality](#code-quality)
- [Serverless Deployment](#serverless-deployment)
  - [AWS Lambda Configuration](#aws-lambda-configuration)
  - [Serverless Framework](#serverless-framework)

---

## Overview

This document outlines the best practices, conventions, and standards used in the LTI backend application. The backend follows Domain-Driven Design (DDD) principles and implements a layered architecture to ensure code consistency, maintainability, and scalability.

## Technology Stack

### Core Technologies
- **Node.js**: Runtime environment
- **TypeScript**: Type-safe development with strict mode
- **Express.js**: Web application framework
- **Prisma**: Modern ORM for database access

### Database & ORM
- **PostgreSQL**: Relational database (Docker container)
- **Prisma Client**: Type-safe database client
- **Prisma Migrate**: Database migration tool

### Testing Framework
- **Jest**: Testing framework with TypeScript support
- **Coverage Threshold**: 90% for branches, functions, lines, and statements
- **Test Location**: `__tests__` directories and `.test.ts` files

### Development Tools
- **ESLint**: Code linting
- **TypeScript Compiler**: Type checking and compilation
- **Serverless Framework**: AWS Lambda deployment support

## Architecture Overview

### Domain-Driven Design (DDD)

Domain-Driven Design is a methodology that focuses on modeling software according to business logic and domain knowledge. By centering development on a deep understanding of the domain, DDD facilitates the creation of complex systems.

**Benefits:**
- **Improved Communication**: Promotes a common language between developers and domain experts, improving communication and reducing interpretation errors.
- **Clear Domain Models**: Helps build models that accurately reflect business rules and processes.
- **High Maintainability**: By dividing the system into subdomains, it facilitates maintenance and software evolution.

### Layered Architecture

The backend follows a layered DDD architecture:

**Presentation Layer** (`src/presentation/`)
- Controllers handle HTTP requests/responses
- Routes define API endpoints
- Controllers use services from Application layer

**Application Layer** (`src/application/`)
- Services contain business logic and orchestration
- Validator handles input validation
- Services use repositories from Domain layer

**Domain Layer** (`src/domain/`)
- Models define core business entities (Candidate, Position, Application, Interview, etc.)
- Repository interfaces define data access contracts
- Pure business logic without external dependencies

**Infrastructure Layer** (implicit)
- Prisma ORM handles database operations
- Repository implementations (via Prisma) satisfy domain interfaces

### Project Structure

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ models/          # Domain entities
â”‚   â”‚   â””â”€â”€ repositories/    # Repository interfaces
â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”œâ”€â”€ services/        # Business logic services
â”‚   â”‚   â””â”€â”€ validator.ts     # Input validation
â”‚   â”œâ”€â”€ presentation/
â”‚   â”‚   â””â”€â”€ controllers/     # HTTP request handlers
â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”œâ”€â”€ logger.ts        # Logging utilities
â”‚   â”‚   â””â”€â”€ prismaClient.ts  # Prisma client setup
â”‚   â”œâ”€â”€ routes/              # Express route definitions
â”‚   â”œâ”€â”€ middleware/          # Express middleware
â”‚   â”œâ”€â”€ index.ts             # Application entry point
â”‚   â””â”€â”€ lambda.ts            # AWS Lambda handler
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma        # Database schema
â”‚   â””â”€â”€ migrations/          # Database migrations
â”œâ”€â”€ test-utils/
â”‚   â”œâ”€â”€ builders/            # Test data builders
â”‚   â””â”€â”€ mocks/               # Mock helpers
â”œâ”€â”€ jest.config.js           # Jest configuration
â”œâ”€â”€ tsconfig.json            # TypeScript configuration
â”œâ”€â”€ serverless.yml           # Serverless Framework config
â””â”€â”€ package.json             # Dependencies and scripts
```

## Domain-Driven Design Principles

### Entities

Entities are objects with a distinct identity that persists over time.

**Before:**
```typescript
// Previously, candidate data might have been handled as a simple JSON object without methods.
const candidate = {
    id: 1,
    firstName: 'John',
    lastName: 'Doe',
    email: 'john.doe@example.com'
};
```

**After:**
```typescript
export class Candidate {
    id?: number;
    firstName: string;
    lastName: string;
    email: string;
    
    // Constructor and methods that encapsulate business logic
    constructor(data: any) {
        this.id = data.id;
        this.firstName = data.firstName;
        this.lastName = data.lastName;
        this.email = data.email;
    }
}
```

**Explanation**: `Candidate` is an entity because it has a unique identifier (`id`) that distinguishes it from other candidates, even if other properties are identical.

**Best Practice**: Entities should encapsulate business logic related to their domain concept and maintain consistency of their internal state.

### Value Objects

Value Objects describe aspects of the domain without conceptual identity. They are defined by their attributes rather than an identifier.

**Before:**
```typescript
// Handling education information as a simple object
const education = {
    institution: 'University',
    degree: 'Bachelor',
    startDate: '2010-01-01',
    endDate: '2014-01-01'
};
```

**After:**
```typescript
export class Education {
    institution: string;
    title: string;
    startDate: Date;
    endDate?: Date;
    
    constructor(data: any) {
        this.institution = data.institution;
        this.title = data.title;
        this.startDate = new Date(data.startDate);
        this.endDate = data.endDate ? new Date(data.endDate) : undefined;
    }
}
```

**Explanation**: `Education` can be considered a Value Object in some contexts, as it describes a candidate's education without needing a unique identifier. However, in the current model, it has been assigned an id, which could contradict the pure definition of a Value Object in DDD.

**Recommendation**: Classes like `Education` and `WorkExperience` currently have unique identifiers, classifying them as entities. In many cases, these could be treated as Value Objects within the context of a `Candidate` aggregate. Consider removing unique identifiers from classes that should be Value Objects, or incorporating them as part of the Candidate document if using a NoSQL database.

### Aggregates

Aggregates are clusters of objects that must be treated as a unit. They have a root entity that enforces invariants and consistency boundaries.

**Before:**
```typescript
// Candidate and education data handled separately
const candidate = { id: 1, name: 'John Doe' };
const educations = [{ candidateId: 1, institution: 'University' }];
```

**After:**
```typescript
export class Candidate {
    id?: number;
    firstName: string;
    lastName: string;
    email: string;
    educations: Education[];
    
    constructor(data: any) {
        this.id = data.id;
        this.firstName = data.firstName;
        this.lastName = data.lastName;
        this.email = data.email;
        this.educations = data.educations?.map(edu => new Education(edu)) || [];
    }
}
```

**Explanation**: `Candidate` acts as an aggregate root that contains `Education`, `WorkExperience`, `Resume`, and `Application`. `Candidate` is the root of the aggregate, as the other entities only make sense in relation to a candidate.

**Recommendation**: Aggregates should be carefully designed to ensure that all operations within the aggregate boundary maintain consistency. Operations that affect `Education` and `WorkExperience` should be handled through the aggregate root, `Candidate`, to maintain integrity and encapsulation.

### Repositories

Repositories provide interfaces for accessing aggregates and entities, encapsulating data access logic.

**Before:**
```typescript
// Direct database access without abstraction
function getCandidateById(id: number) {
    return database.query('SELECT * FROM candidates WHERE id = ?', [id]);
}
```

**After:**
```typescript
export interface ICandidateRepository {
    findById(id: number): Promise<Candidate | null>;
    save(candidate: Candidate): Promise<Candidate>;
    findAll(): Promise<Candidate[]>;
}

export class CandidateRepository implements ICandidateRepository {
    async findById(id: number): Promise<Candidate | null> {
        const data = await prisma.candidate.findUnique({ where: { id } });
        return data ? new Candidate(data) : null;
    }
    
    async save(candidate: Candidate): Promise<Candidate> {
        // Implementation with Prisma
    }
}
```

**Explanation**: `CandidateRepository` provides a clear interface for accessing candidate data, encapsulating database access logic.

**Recommendation**: 
- Develop complete repository interfaces for each entity and aggregate, ensuring all database interactions for those entities pass through the repository
- Implement repository methods that handle collections of entities, such as lists of Candidates, that can be filtered or modified in bulk
- Use dependency injection to inject Prisma client into repositories

### Domain Services

Domain Services contain business logic that doesn't naturally belong to an entity or value object.

**Before:**
```typescript
// Loose functions to handle business logic
function calculateAge(candidate: any): number {
    const today = new Date();
    const birthDate = new Date(candidate.birthDate);
    let age = today.getFullYear() - birthDate.getFullYear();
    const m = today.getMonth() - birthDate.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
        age--;
    }
    return age;
}
```

**After:**
```typescript
export class CandidateService {
    static calculateAge(candidate: Candidate): number {
        const today = new Date();
        const birthDate = new Date(candidate.birthDate);
        let age = today.getFullYear() - birthDate.getFullYear();
        const m = today.getMonth() - birthDate.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
            age--;
        }
        return age;
    }
}
```

**Explanation**: `CandidateService` encapsulates business logic related to candidates, such as calculating age, providing a centralized and coherent point for handling these operations.

### Additional Recommendations

**Use of Factories**

Factories are useful in DDD to encapsulate the logic of creating complex objects, ensuring that all created objects comply with domain rules from the moment of creation.

**Recommendation**: Implement factories for the creation of entities and aggregates, especially those that are complex and require specific initial configuration that complies with business rules.

**Improvement in Relationship Modeling**

Relationships between entities and aggregates must be clear and consistent with business rules.

**Recommendation**: Review and possibly redesign relationships between entities to ensure they accurately reflect domain needs and rules. This may include removing unnecessary relationships or adding new relationships that facilitate business operations.

**Domain Events Integration**

Domain events are an important part of DDD and can be used to handle side effects of domain operations in a decoupled manner.

**Recommendation**: Implement a domain event system that allows entities and aggregates to publish events that other system components can handle without being tightly coupled to the entities that generate them.

## SOLID and DRY Principles

### SOLID Principles

SOLID principles are five object-oriented design principles that help create more understandable, flexible, and maintainable systems.

#### Single Responsibility Principle (SRP)

Each class should have a single responsibility or reason to change.

**Before:**
```typescript
// A method that handles multiple responsibilities: validation and data storage
function processCandidate(candidate: any) {
    if (!candidate.email.includes('@')) {
        console.error('Invalid email');
        return;
    }
    database.save(candidate);
    console.log('Candidate saved');
}
```

**After:**
```typescript
export class Candidate {
    // The class now only handles logic related to the candidate
    validateEmail(): void {
        if (!this.email.includes('@')) {
            throw new Error('Invalid email');
        }
    }
}

export class CandidateRepository {
    async save(candidate: Candidate): Promise<Candidate> {
        candidate.validateEmail();
        return await prisma.candidate.create({ data: candidate });
    }
}
```

**Explanation**: The `Candidate` class now has separate methods for validation, while the repository handles data persistence, complying with the single responsibility principle.

**Observation**: The `Candidate` class in `backend/src/domain/models/Candidate.ts` handles both business logic and data access logic.

**Recommendation**: Separate data access logic into a repository layer to adhere more closely to SRP.

#### Open/Closed Principle (OCP)

Software entities should be open for extension but closed for modification.

**Before:**
```typescript
// Direct modification of the class to add functionality
class Candidate {
    saveToDatabase() {
        // code to save to database
    }
    // To add new functionality, we modify the class directly
    sendEmail() {
        // code to send an email
    }
}
```

**After:**
```typescript
export class Candidate {
    saveToDatabase() {
        // code to save to database
    }
}

// Extend functionality without modifying the existing class
class CandidateWithEmail extends Candidate {
    sendEmail() {
        // code to send an email
    }
}
```

**Explanation**: The email sending functionality is extended in a subclass, keeping the original class closed for modifications but open for extensions.

**Observation**: The `addCandidate` function in `backend/src/application/services/candidateService.ts` directly instantiates `Candidate`, `Education`, `WorkExperience`, and `Resume` classes.

**Recommendation**: Use factory methods to create instances, allowing for easier extension without modifying existing code.

#### Liskov Substitution Principle (LSP)

Objects of a derived class should be replaceable with objects of the base class without altering the program's functionality.

**Before:**
```typescript
// Subclass that cannot completely replace its base class
class TemporaryCandidate extends Candidate {
    saveToDatabase() {
        throw new Error("Temporary candidates can't be saved.");
    }
}
```

**After:**
```typescript
class TemporaryCandidate extends Candidate {
    saveToDatabase() {
        // Appropriate implementation that allows temporary handling
        console.log("Handled temporarily");
        // Alternative: Save to temporary storage
    }
}
```

**Explanation**: `TemporaryCandidate` now provides an appropriate implementation that respects the base class contract, allowing substitution without errors.

**Observation**: Currently, there is no inheritance in use where LSP could be violated. The project uses composition over inheritance, which generally supports LSP.

**Recommendation**: Continue using composition to avoid LSP violations and ensure that any future inheritance structures allow derived classes to substitute their base classes without altering how the program works.

#### Interface Segregation Principle (ISP)

Many specific interfaces are better than a single general interface.

**Before:**
```typescript
// A large interface that small clients don't fully use
interface CandidateOperations {
    save(): void;
    validate(): void;
    sendEmail(): void;
    generateReport(): void;
}
```

**After:**
```typescript
interface SaveOperation {
    save(): void;
}

interface EmailOperations {
    sendEmail(): void;
}

interface ReportOperations {
    generateReport(): void;
}

class Candidate implements SaveOperation, EmailOperations {
    save() {
        // implementation
    }
    
    sendEmail() {
        // implementation
    }
}
```

**Explanation**: Interfaces are segregated into smaller operations, allowing classes to implement only the interfaces they need.

**Observation**: The project does not currently use TypeScript interfaces extensively to enforce contracts for classes.

**Recommendation**: Define more granular interfaces for service classes to ensure they only implement the methods they need.

#### Dependency Inversion Principle (DIP)

High-level modules should not depend on low-level modules; both should depend on abstractions.

**Before:**
```typescript
// Direct dependency on a concrete implementation
class Candidate {
    private database = new PrismaClient();
    
    save() {
        this.database.candidate.create({ data: this });
    }
}
```

**After:**
```typescript
interface Database {
    save(candidate: Candidate): Promise<Candidate>;
}

class Candidate {
    private database: Database;
    
    constructor(database: Database) {
        this.database = database;
    }
    
    async save(): Promise<Candidate> {
        return await this.database.save(this);
    }
}
```

**Explanation**: `Candidate` now depends on an abstraction (Database), not a concrete implementation, which facilitates flexibility and code testing.

**Observation**: Classes like `Candidate` directly depend on the concrete `PrismaClient` for database operations.

**Recommendation**: Use dependency injection to invert the dependency, relying on abstractions rather than concrete implementations. Inject `PrismaClient` through the constructor or a setter method.

### DRY (Don't Repeat Yourself)

The DRY principle focuses on reducing duplication in code. Each piece of knowledge should have a single, unambiguous, and authoritative representation within a system.

**Before:**
```typescript
// Repeated code to validate emails in multiple functions
function saveCandidate(candidate: Candidate) {
    if (!candidate.email.includes('@')) {
        throw new Error('Invalid email');
    }
    // save logic
}

function updateCandidate(candidate: Candidate) {
    if (!candidate.email.includes('@')) {
        throw new Error('Invalid email');
    }
    // update logic
}
```

**After:**
```typescript
export class Candidate {
    validateEmail(): void {
        if (!this.email.includes('@')) {
            throw new Error('Invalid email');
        }
    }
    
    async save(): Promise<Candidate> {
        this.validateEmail();
        // save logic
    }
    
    async update(): Promise<Candidate> {
        this.validateEmail();
        // update logic
    }
}
```

**Explanation**: Email validation is centralized in a single `validateEmail` method, eliminating code duplication in the save and update functions.

**Observation**: The methods for saving entities like `Candidate`, `Education`, `WorkExperience`, and `Resume` contain repetitive logic for handling database operations.

**Recommendation**: Abstract common database operation logic into a reusable function or class.

## Coding Standards

### Naming Conventions

- **Variable Naming**: Use camelCase for variables and functions (e.g., `candidateId`, `findCandidateById`)
- **Class Naming**: Use PascalCase for classes and interfaces (e.g., `Candidate`, `CandidateRepository`)
- **Constants Naming**: Use UPPER_SNAKE_CASE for constants (e.g., `MAX_CANDIDATES_PER_PAGE`)
- **Type Naming**: Use PascalCase for types and interfaces (e.g., `CandidateData`, `ICandidateRepository`)
- **File Naming**: Use camelCase for file names (e.g., `candidateService.ts`, `candidateController.ts`)

**Examples:**

```typescript
// Good: All in English
export class CandidateRepository {
    async findById(candidateId: number): Promise<Candidate | null> {
        // Find candidate by ID in the database
        const candidate = await this.prisma.candidate.findUnique({
            where: { id: candidateId }
        });
        return candidate ? new Candidate(candidate) : null;
    }
}

// Avoid: Non-English comments or names
export class RepositorioCandidato {
    async buscarPorId(idCandidato: number): Promise<Candidato | null> {
        // Buscar candidato por ID en la base de datos
        const candidato = await this.prisma.candidate.findUnique({
            where: { id: idCandidato }
        });
        return candidato ? new Candidato(candidato) : null;
    }
}
```

**Error Messages and Logs:**

```typescript
// Good: English error messages
throw new NotFoundError('Candidate not found with the provided ID');
logger.error('Failed to create candidate', { error: error.message });

// Avoid: Non-English messages
throw new NotFoundError('Candidato no encontrado con el ID proporcionado');
logger.error('Error al crear candidato', { error: error.message });
```

### TypeScript Usage

- **Strict Mode**: Always enable strict mode in `tsconfig.json`
- **Type Definitions**: Use explicit types for function parameters and return values
- **Interfaces**: Define interfaces for complex data structures
- **Avoid `any`**: Use `unknown` or specific types instead of `any` when possible

```typescript
// Good: Explicit types
async function findCandidateById(id: number): Promise<Candidate | null> {
    // implementation
}

// Avoid: Using any
function processData(data: any): any {
    // implementation
}
```

### Error Handling

- **Custom Error Classes**: Create domain-specific error classes
- **Error Middleware**: Use global error middleware for consistent error responses
- **Error Messages**: Provide descriptive error messages for debugging

```typescript
export class NotFoundError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'NotFoundError';
    }
}

// In controller
try {
    const candidate = await candidateService.findById(id);
    if (!candidate) {
        throw new NotFoundError('Candidate not found');
    }
    res.json(candidate);
} catch (error) {
    next(error);
}
```

### Validation Patterns

- **Input Validation**: Validate all inputs at the application layer
- **Use Validator Module**: Centralize validation logic in `src/application/validator.ts`
- **Validate Before Processing**: Always validate before executing business logic

```typescript
import { validateCandidateData } from '../application/validator';

export async function addCandidate(req: Request, res: Response, next: NextFunction) {
    try {
        const validatedData = validateCandidateData(req.body);
        const candidate = await candidateService.create(validatedData);
        res.status(201).json(candidate);
    } catch (error) {
        next(error);
    }
}
```

### Logging Standards

- **Use Logger Class**: Use the centralized logger from `src/infrastructure/logger.ts`
- **Log Levels**: Use appropriate log levels (info, error, warn, debug)
- **Structured Logging**: Include relevant context in log messages

```typescript
import { Logger } from '../infrastructure/logger';

const logger = new Logger();

logger.info('Candidate created', { candidateId: candidate.id });
logger.error('Failed to create candidate', { error: error.message });
```

## API Design Standards

### REST Endpoints

- **RESTful Naming**: Use RESTful conventions for endpoint naming
- **HTTP Methods**: Use appropriate HTTP methods (GET, POST, PUT, DELETE, PATCH)
- **Resource-Based URLs**: URLs should represent resources, not actions

```typescript
GET    /candidates          // List candidates
GET    /candidates/:id      // Get candidate by ID
POST   /candidates          // Create new candidate
PUT    /candidates/:id      // Update candidate
DELETE /candidates/:id      // Delete candidate
```

### Request/Response Patterns

- **JSON Format**: Use JSON for request and response bodies
- **Consistent Structure**: Maintain consistent response structure across all endpoints
- **Status Codes**: Use appropriate HTTP status codes

```typescript
// Success response
{
    "success": true,
    "data": { ... },
    "message": "Operation completed successfully"
}

// Error response
{
    "success": false,
    "error": {
        "message": "Error description",
        "code": "ERROR_CODE"
    }
}
```

### Error Response Format

- **Consistent Format**: All errors should follow the same response structure
- **Error Codes**: Use meaningful error codes for different error types
- **HTTP Status Codes**: Map errors to appropriate HTTP status codes

```typescript
// 400 Bad Request
{
    "success": false,
    "error": {
        "message": "Validation failed",
        "code": "VALIDATION_ERROR",
        "details": [ ... ]
    }
}

// 404 Not Found
{
    "success": false,
    "error": {
        "message": "Resource not found",
        "code": "NOT_FOUND"
    }
}
```

### CORS Configuration

- **Enable CORS**: Configure CORS to allow frontend origin
- **Secure Configuration**: Only allow specific origins in production
- **Credentials**: Configure credentials handling appropriately

```typescript
import cors from 'cors';

const corsOptions = {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
};

app.use(cors(corsOptions));
```

## Database Patterns

### Prisma Schema

- **Single Source of Truth**: `prisma/schema.prisma` is the single source of truth for database structure
- **Relationships**: Define relationships using Prisma relations
- **Naming Conventions**: Use consistent naming conventions (camelCase for fields, PascalCase for models)

### Migrations

- **Version Control**: All database changes must be version-controlled through migrations
- **Migration Naming**: Use descriptive names for migrations
- **Review Migrations**: Review migration files before applying

```bash
# Create migration
npx prisma migrate dev --name descriptive_migration_name

# Apply migrations in production
npx prisma migrate deploy
```

### Database Seeding Strategy

Database seeding is essential for local development and testing. Jaarvi requires specific seed data to function properly.

#### Seed Data Requirements (MVP)

**1. Activity Type Configurations** (`ActivityTypeConfig`)

Activity types define the categories of activities travelers can create. Some types (like accommodation) are mandatory per day.

```typescript
// prisma/seeds/activityTypes.ts
export const activityTypeSeeds = [
  {
    key: 'sleep',
    displayName: 'Accommodation',
    isMandatoryDaily: true,
    requiresEvidence: true,
    allowNotNeeded: false
  },
  {
    key: 'transfer',
    displayName: 'Transportation',
    isMandatoryDaily: false,
    requiresEvidence: false,
    allowNotNeeded: true
  },
  {
    key: 'visit',
    displayName: 'Visit/Attraction',
    isMandatoryDaily: false,
    requiresEvidence: false,
    allowNotNeeded: true
  },
  {
    key: 'meal',
    displayName: 'Meal',
    isMandatoryDaily: false,
    requiresEvidence: false,
    allowNotNeeded: true
  },
  {
    key: 'free_time',
    displayName: 'Free Time',
    isMandatoryDaily: false,
    requiresEvidence: false,
    allowNotNeeded: true
  }
];
```

**2. Countries & Cities** (`Country`, `City`, `CityCoverage`)

Initial MVP destinations with coverage information:

```typescript
// prisma/seeds/destinations.ts
export const destinationSeeds = [
  {
    country: {
      isoCode: 'FR',
      name: 'France'
    },
    cities: [
      {
        name: 'Paris',
        timezone: 'Europe/Paris',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      },
      {
        name: 'Lyon',
        timezone: 'Europe/Paris',
        coverage: { level: 'medium', notes: 'Basic guidance only' }
      }
    ]
  },
  {
    country: {
      isoCode: 'IT',
      name: 'Italy'
    },
    cities: [
      {
        name: 'Rome',
        timezone: 'Europe/Rome',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      },
      {
        name: 'Florence',
        timezone: 'Europe/Rome',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      },
      {
        name: 'Venice',
        timezone: 'Europe/Rome',
        coverage: { level: 'medium', notes: 'Expanding coverage' }
      }
    ]
  },
  {
    country: {
      isoCode: 'ES',
      name: 'Spain'
    },
    cities: [
      {
        name: 'Barcelona',
        timezone: 'Europe/Madrid',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      },
      {
        name: 'Madrid',
        timezone: 'Europe/Madrid',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      }
    ]
  },
  {
    country: {
      isoCode: 'JP',
      name: 'Japan'
    },
    cities: [
      {
        name: 'Tokyo',
        timezone: 'Asia/Tokyo',
        coverage: { level: 'medium', notes: 'Expanding coverage' }
      },
      {
        name: 'Kyoto',
        timezone: 'Asia/Tokyo',
        coverage: { level: 'medium', notes: 'Expanding coverage' }
      },
      {
        name: 'Osaka',
        timezone: 'Asia/Tokyo',
        coverage: { level: 'medium', notes: 'Expanding coverage' }
      }
    ]
  },
  {
    country: {
      isoCode: 'GB',
      name: 'United Kingdom'
    },
    cities: [
      {
        name: 'London',
        timezone: 'Europe/London',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      }
    ]
  },
  {
    country: {
      isoCode: 'US',
      name: 'United States'
    },
    cities: [
      {
        name: 'New York',
        timezone: 'America/New_York',
        coverage: { level: 'high', notes: 'Full playbooks available' }
      },
      {
        name: 'San Francisco',
        timezone: 'America/Los_Angeles',
        coverage: { level: 'medium', notes: 'Basic guidance' }
      }
    ]
  }
];
```

**3. Test Users** (Development Only)

Create test accounts for development and testing:

```typescript
// prisma/seeds/users.ts
import { hashPassword } from '../src/infrastructure/auth';

export const testUserSeeds = [
  {
    email: 'test@jaarvi.app',
    displayName: 'Test User',
    emailVerifiedAt: new Date(),
    status: 'active',
    credential: {
      passwordHash: await hashPassword('TestPassword123'),
      passwordAlgo: 'argon2id'
    }
  },
  {
    email: 'demo@jaarvi.app',
    displayName: 'Demo User',
    emailVerifiedAt: new Date(),
    status: 'active',
    credential: {
      passwordHash: await hashPassword('DemoPassword123'),
      passwordAlgo: 'argon2id'
    }
  },
  {
    email: 'admin@jaarvi.app',
    displayName: 'Admin User',
    emailVerifiedAt: new Date(),
    status: 'active',
    credential: {
      passwordHash: await hashPassword('AdminPassword123'),
      passwordAlgo: 'argon2id'
    }
  }
];
```

**4. Sample Trip Data** (Development Only)

Example trips for testing UI and flows:

```typescript
// prisma/seeds/sampleTrips.ts
export const sampleTripSeeds = [
  {
    name: 'France & Italy Adventure',
    ownerId: 'test-user-uuid', // Will be resolved after user creation
    startDate: new Date('2026-03-15'),
    endDate: new Date('2026-03-28'),
    status: 'draft',
    destinations: [
      {
        cityName: 'Paris',
        dayOrder: 1,
        daysCount: 5,
        notes: 'Explore the City of Light'
      },
      {
        cityName: 'Rome',
        dayOrder: 2,
        daysCount: 4,
        notes: 'Ancient history and amazing food'
      },
      {
        cityName: 'Florence',
        dayOrder: 3,
        daysCount: 4,
        notes: 'Renaissance art and architecture'
      }
    ]
  },
  {
    name: 'Japan Discovery',
    ownerId: 'demo-user-uuid',
    startDate: new Date('2026-04-05'),
    endDate: new Date('2026-04-19'),
    status: 'active',
    destinations: [
      {
        cityName: 'Tokyo',
        dayOrder: 1,
        daysCount: 7,
        notes: 'Modern metropolis'
      },
      {
        cityName: 'Kyoto',
        dayOrder: 2,
        daysCount: 4,
        notes: 'Traditional temples and gardens'
      },
      {
        cityName: 'Osaka',
        dayOrder: 3,
        daysCount: 3,
        notes: 'Street food paradise'
      }
    ]
  }
];
```

#### Seed Execution Commands

Add these scripts to `package.json`:

```json
{
  "scripts": {
    "seed": "ts-node prisma/seed.ts",
    "seed:activity-types": "ts-node prisma/seeds/activityTypes.ts",
    "seed:destinations": "ts-node prisma/seeds/destinations.ts",
    "seed:test-users": "ts-node prisma/seeds/users.ts",
    "seed:sample-trips": "ts-node prisma/seeds/sampleTrips.ts"
  }
}
```

**Usage**:

```bash
# Run all seeds (recommended for fresh database)
npm run seed

# Run specific seeds (for targeted updates)
npm run seed:activity-types
npm run seed:destinations
npm run seed:test-users
npm run seed:sample-trips
```

#### Seed Script Structure

Create a comprehensive seed script that runs all seeds in the correct order:

```typescript
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';
import { activityTypeSeeds } from './seeds/activityTypes';
import { destinationSeeds } from './seeds/destinations';
import { testUserSeeds } from './seeds/users';
import { sampleTripSeeds } from './seeds/sampleTrips';
import { hashPassword } from '../src/infrastructure/auth';

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸŒ± Starting database seeding...');
  
  // ========================================
  // 1. Seed Activity Types (Required)
  // ========================================
  console.log('\nðŸ“ Seeding activity types...');
  for (const type of activityTypeSeeds) {
    await prisma.activityTypeConfig.upsert({
      where: { key: type.key },
      update: type,
      create: type
    });
    console.log(`  âœ“ ${type.displayName} (${type.key})`);
  }
  
  // ========================================
  // 2. Seed Destinations (Required)
  // ========================================
  console.log('\nðŸ—ºï¸  Seeding destinations...');
  for (const dest of destinationSeeds) {
    // Create or update country
    const country = await prisma.country.upsert({
      where: { isoCode: dest.country.isoCode },
      update: { name: dest.country.name },
      create: dest.country
    });
    console.log(`  âœ“ ${country.name} (${country.isoCode})`);
    
    // Create or update cities
    for (const cityData of dest.cities) {
      const city = await prisma.city.upsert({
        where: {
          countryId_name: {
            countryId: country.id,
            name: cityData.name
          }
        },
        update: {
          timezone: cityData.timezone
        },
        create: {
          countryId: country.id,
          name: cityData.name,
          timezone: cityData.timezone
        }
      });
      
      // Create or update coverage
      await prisma.cityCoverage.upsert({
        where: { cityId: city.id },
        update: {
          level: cityData.coverage.level,
          notes: cityData.coverage.notes
        },
        create: {
          cityId: city.id,
          level: cityData.coverage.level,
          notes: cityData.coverage.notes
        }
      });
      
      console.log(`    â€¢ ${cityData.name} (${cityData.coverage.level} coverage)`);
    }
  }
  
  // ========================================
  // 3. Seed Test Users (Development Only)
  // ========================================
  if (process.env.NODE_ENV === 'development') {
    console.log('\nðŸ‘¥ Seeding test users...');
    
    for (const userData of testUserSeeds) {
      const passwordHash = await hashPassword(userData.credential.passwordHash);
      
      const user = await prisma.user.upsert({
        where: { email: userData.email },
        update: {},
        create: {
          email: userData.email,
          displayName: userData.displayName,
          emailVerifiedAt: userData.emailVerifiedAt,
          status: userData.status
        }
      });
      
      // Create credential
      await prisma.userCredential.upsert({
        where: { userId: user.id },
        update: {
          passwordHash,
          passwordAlgo: 'argon2id',
          passwordUpdatedAt: new Date()
        },
        create: {
          userId: user.id,
          passwordHash,
          passwordAlgo: 'argon2id',
          passwordUpdatedAt: new Date()
        }
      });
      
      console.log(`  âœ“ ${userData.email}`);
    }
    
    // ========================================
    // 4. Seed Sample Trips (Development Only)
    // ========================================
    console.log('\nâœˆï¸  Seeding sample trips...');
    
    const testUser = await prisma.user.findUnique({
      where: { email: 'test@jaarvi.app' }
    });
    const demoUser = await prisma.user.findUnique({
      where: { email: 'demo@jaarvi.app' }
    });
    
    if (testUser && demoUser) {
      for (const tripData of sampleTripSeeds) {
        const ownerId = tripData.ownerId === 'test-user-uuid' ? testUser.id : demoUser.id;
        
        const trip = await prisma.trip.create({
          data: {
            name: tripData.name,
            ownerId,
            startDate: tripData.startDate,
            endDate: tripData.endDate,
            status: tripData.status
          }
        });
        
        console.log(`  âœ“ ${tripData.name}`);
        
        // Add destinations
        for (const destData of tripData.destinations) {
          const city = await prisma.city.findFirst({
            where: { name: destData.cityName }
          });
          
          if (city) {
            await prisma.tripDestination.create({
              data: {
                tripId: trip.id,
                cityId: city.id,
                dayOrder: destData.dayOrder,
                daysCount: destData.daysCount,
                notes: destData.notes
              }
            });
            console.log(`    â€¢ ${destData.cityName} (${destData.daysCount} days)`);
          }
        }
      }
    }
  } else {
    console.log('\nâ­ï¸  Skipping test users and sample trips (not in development mode)');
  }
  
  console.log('\nâœ… Database seeding completed successfully!');
}

main()
  .catch((e) => {
    console.error('âŒ Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Configure Prisma to use seed script**:

Add to `prisma/schema.prisma`:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Add this section
// prisma db seed will use this configuration
```

Add to `package.json`:

```json
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
```

#### Migration Best Practices

**Migration Naming Convention**:

Use descriptive names that clearly indicate what the migration does:

```bash
# Good examples
npx prisma migrate dev --name add_user_authentication_tables
npx prisma migrate dev --name create_trip_and_destination_tables
npx prisma migrate dev --name add_activity_mandatory_fields
npx prisma migrate dev --name add_document_vault_tables
npx prisma migrate dev --name add_oauth_support

# Avoid vague names
npx prisma migrate dev --name update_db
npx prisma migrate dev --name fixes
```

**Migration Review Checklist**:

Before applying migrations, review the generated SQL:

- [ ] Review generated SQL in `prisma/migrations/[timestamp]_[name]/migration.sql`
- [ ] Verify foreign key constraints are correct
- [ ] Check indexes on frequently queried fields (userId, tripId, etc.)
- [ ] Ensure NOT NULL constraints don't break existing data
- [ ] Test migration on local database first
- [ ] Document breaking changes in migration file comments
- [ ] Verify unique constraints are appropriate
- [ ] Check cascade delete behavior (ON DELETE CASCADE/SET NULL)

**Rollback Strategy**:

While Prisma doesn't support automatic rollbacks, follow these practices:

- **Keep migrations small and atomic**: One logical change per migration
- **Test rollback procedures locally**: Create manual rollback SQL scripts for complex migrations
- **Backup database before production migrations**: Always create a snapshot before applying migrations
- **Use transactions where possible**: Prisma migrations run in transactions by default
- **Manual rollback scripts**: For critical migrations, prepare rollback SQL:

```sql
-- Example rollback script for adding a column
-- Migration: add_activity_readiness_fields
-- To rollback:
ALTER TABLE "Activity" DROP COLUMN IF EXISTS "isMandatory";
ALTER TABLE "Activity" DROP COLUMN IF EXISTS "readinessStatus";
ALTER TABLE "Activity" DROP COLUMN IF EXISTS "readinessNote";
ALTER TABLE "Activity" DROP COLUMN IF EXISTS "preparedAt";
```

**Data Migration for Existing Users**:

When schema changes require data transformation, include data migration SQL:

```typescript
// Example: Migrating existing trips to add mandatory activities
// prisma/migrations/[timestamp]_add_mandatory_activities/migration.sql

-- Step 1: Add new fields
ALTER TABLE "Activity" ADD COLUMN "isMandatory" BOOLEAN DEFAULT false;
ALTER TABLE "Activity" ADD COLUMN "readinessStatus" VARCHAR(20) DEFAULT 'pending';
ALTER TABLE "Activity" ADD COLUMN "readinessNote" TEXT;
ALTER TABLE "Activity" ADD COLUMN "preparedAt" TIMESTAMP;

-- Step 2: Create mandatory sleep activities for existing day plans
INSERT INTO "Activity" (
  "id",
  "dayPlanId", 
  "activityTypeKey", 
  "type", 
  "title", 
  "isMandatory", 
  "readinessStatus",
  "sortOrder"
)
SELECT 
  gen_random_uuid(),
  dp.id,
  'sleep',
  'booking',
  'Accommodation',
  true,
  'pending',
  999  -- Place at end of day
FROM "DayPlan" dp
WHERE NOT EXISTS (
  SELECT 1 FROM "Activity" a 
  WHERE a."dayPlanId" = dp.id 
  AND a."activityTypeKey" = 'sleep'
);

-- Step 3: Update existing accommodation activities to mandatory
UPDATE "Activity"
SET 
  "isMandatory" = true,
  "activityTypeKey" = 'sleep'
WHERE 
  "type" = 'booking'
  AND ("title" ILIKE '%hotel%' OR "title" ILIKE '%accommodation%' OR "title" ILIKE '%hostel%');

-- Step 4: Add helpful comment
COMMENT ON COLUMN "Activity"."isMandatory" IS 'Indicates if this activity type is mandatory per day (e.g., accommodation)';
```

**Migration Testing Process**:

1. **Local Testing**:
   ```bash
   # Create migration
   npx prisma migrate dev --name add_new_feature
   
   # Test with seed data
   npm run seed
   
   # Verify application works
   npm run dev
   ```

2. **Staging Environment**:
   ```bash
   # Apply migration to staging
   npx prisma migrate deploy
   
   # Run integration tests
   npm test
   
   # Manual QA testing
   ```

3. **Production Deployment**:
   ```bash
   # Backup database
   pg_dump -h production-db-host -U user -d jaarvi_prod > backup_$(date +%Y%m%d_%H%M%S).sql
   
   # Apply migration
   npx prisma migrate deploy
   
   # Verify application health
   curl https://api.jaarvi.app/health
   ```

### Repository Pattern

- **Repository Interfaces**: Define repository interfaces in the domain layer
- **Prisma Implementation**: Implement repositories using Prisma in the infrastructure layer
- **Dependency Injection**: Inject Prisma client into repositories

```typescript
// Domain layer interface
export interface ICandidateRepository {
    findById(id: number): Promise<Candidate | null>;
    save(candidate: Candidate): Promise<Candidate>;
}

// Infrastructure layer implementation
export class CandidateRepository implements ICandidateRepository {
    constructor(private prisma: PrismaClient) {}
    
    async findById(id: number): Promise<Candidate | null> {
        const data = await this.prisma.candidate.findUnique({ where: { id } });
        return data ? new Candidate(data) : null;
    }
}
```

## Testing Standards

The project has strict requirements for code quality and maintainability. These are the unit testing standards and best practices that must be applied. 

### Test File Structure
- Use descriptive test file names: `[componentName].test.ts`
- Place test files alongside the source code they test
- Use Jest as the testing framework with TypeScript support
- Maintain 90% coverage threshold for branches, functions, lines, and statements


### Test Organization Pattern
Template:
```typescript
describe('[ComponentName] - [methodName]', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('should_[expected_behavior]_when_[condition]', () => {
    it('should [specific test case]', async () => {
      // Arrange
      // Act  
      // Assert
    });
  });
});
```

Real example:
```typescript
describe('CandidateService - findById', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('should return candidate when found', async () => {
        // Arrange
        const candidateId = 1;
        const mockCandidate = new Candidate({ id: 1, firstName: 'John' });
        (CandidateRepository.findById as jest.Mock).mockResolvedValue(mockCandidate);

        // Act
        const result = await candidateService.findById(candidateId);

        // Assert
        expect(result).toEqual(mockCandidate);
        expect(CandidateRepository.findById).toHaveBeenCalledWith(candidateId);
    });
});
```



### Test Case Naming Convention
- Use descriptive, behavior-driven naming: `should_[expected_behavior]_when_[condition]`
- Group related test cases under descriptive `describe` blocks
- Use snake_case for describe blocks and camelCase for individual tests

### Test Structure (AAA Pattern)
Always follow the Arrange-Act-Assert pattern:
```typescript
it('should update candidate stage successfully when valid data provided', async () => {
  // Arrange - Set up test data and mocks
  const candidateId = 1;
  const applicationId = 1;
  const newInterviewStep = 2;
  
  // Act - Execute the function under test
  const result = await updateCandidateStage(candidateId, applicationId, newInterviewStep);
  
  // Assert - Verify the expected behavior
  expect(result).toEqual(expectedResult);
});
```

Assertion pattern:
- Use specific matchers: `toHaveBeenCalledWith()`, `toHaveBeenCalledTimes()`
- Verify both successful operations and error conditions
- Check that mocks were called with correct parameters
- Assert on return values and side effects








### Mocking Standards

- Mock all external dependencies (models, services, database clients)
- Mock repository layers in service tests
- Mock service layers in controller tests
- Use `jest.mock()` at the top of test files for module-level mocking
- Create mock instances with realistic data structures
- Clear all mocks in `beforeEach()` to ensure test isolation


### Test Coverage Requirements

- **Comprehensive test coverage**: Include these test categories for each function:
1. **Happy Path Tests**: Valid inputs producing expected outputs
2. **Error Handling Tests**: Invalid inputs, missing data, database errors
3. **Edge Cases**: Boundary values, null/undefined inputs, empty data
4. **Validation Tests**: Input validation, business rule enforcement
5. **Integration Points**: External service calls, database operations

- **Threshold**: 90% for branches, functions, lines, and statements
- **Coverage Reports**: Generate coverage reports with `npm run test:coverage`
- **Coverage Files**: Coverage reports in `coverage/` directory adding the date, like YYYYMMDD-backend-coverage.md


### Error Testing
- Test both expected errors and unexpected errors
- Verify error messages are descriptive and helpful
- Test error propagation through service layers
- Ensure proper HTTP status codes in controller tests

### Controller Testing Specifics
- Mock the service layer completely
- Test HTTP request/response handling
- Verify parameter parsing and validation
- Test error response formatting
- Use realistic Express Request/Response mocks

### Service Testing Specifics
- Mock domain models and repositories
- Test business logic in isolation
- Verify data transformation and validation
- Test error handling and edge cases
- Mock external dependencies (Prisma, validators)

### Database Testing
- Mock Prisma client and all database operations
- Test both successful and failed database operations
- Verify correct database queries and parameters
- Test transaction handling and rollback scenarios

### Async Testing
- Always use `async/await` for asynchronous operations
- Use `Promise.allSettled()` for testing concurrent operations
- Properly handle promise rejections in tests
- Test timeout scenarios where applicable

### Test Data Management
- Use factory functions for creating test data
- Keep test data consistent and realistic
- Avoid hardcoded values in multiple places
- Use meaningful test data that reflects real-world scenarios

### Integration Testing

- **Controller Testing**: Test HTTP request/response handling
- **Database Testing**: Test repository implementations with database
- **End-to-End Flow**: Test complete request flows


### Code Quality Standards

#### TypeScript Usage
- Use strict typing for all test parameters and return values
- Define proper interfaces for mock data
- Use type assertions sparingly and with proper justification
- Leverage TypeScript's type system for better test reliability

#### Documentation
- Write clear, descriptive test names that explain the scenario
- Add comments for complex test setups
- Document any special test conditions or edge cases
- Keep test code as readable as production code

#### Performance Considerations
- Keep tests fast and focused
- Avoid unnecessary async operations in tests
- Use appropriate mock strategies to avoid real I/O
- Group related tests to minimize setup/teardown overhead

### Integration with Development Workflow
- Run tests before every commit
- Ensure all tests pass before merging
- Use test-driven development when appropriate
- Update tests when modifying existing functionality

### Common Anti-Patterns to Avoid
- Don't test implementation details, test behavior
- Don't create overly complex test setups
- Don't ignore failing tests or skip error scenarios
- Don't use real database connections in unit tests
- Don't create tests that depend on external services
- Don't write tests that are too tightly coupled to implementation

### Example Test Structure



## Performance Best Practices

### Database Query Optimization

- **Select Specific Fields**: Only select fields that are needed
- **Use Indexes**: Ensure proper database indexes for frequently queried fields
- **Avoid N+1 Queries**: Use Prisma's `include` to fetch related data efficiently

```typescript
// Good: Fetch related data efficiently
const candidate = await prisma.candidate.findUnique({
    where: { id },
    include: {
        educations: true,
        workExperiences: true
    }
});

// Avoid: N+1 queries
const candidate = await prisma.candidate.findUnique({ where: { id } });
const educations = await prisma.education.findMany({ where: { candidateId: id } });
```

### Async/Await Patterns

- **Always Use Async/Await**: Use async/await instead of promises chains
- **Error Handling**: Properly handle errors in async operations
- **Parallel Operations**: Use `Promise.all()` for parallel operations when appropriate

```typescript
// Good: Parallel operations
const [candidates, positions] = await Promise.all([
    candidateService.findAll(),
    positionService.findAll()
]);
```

### Error Handling Performance

- **Early Returns**: Return early to avoid unnecessary processing
- **Error Propagation**: Let errors propagate naturally through the call stack
- **Avoid Over-Wrapping**: Don't wrap errors unnecessarily

## Security Best Practices

### Input Validation

- **Validate All Inputs**: Validate all user inputs before processing
- **Sanitize Data**: Sanitize data to prevent injection attacks
- **Type Checking**: Use TypeScript and validation to ensure type safety

### Environment Variables

- **Never Commit Secrets**: Never commit `.env` files or secrets to version control
- **Use Environment Variables**: Use environment variables for configuration
- **Validate Environment**: Validate required environment variables at startup

```typescript
// Validate required environment variables
const requiredEnvVars = ['DATABASE_URL', 'PORT'];
requiredEnvVars.forEach(varName => {
    if (!process.env[varName]) {
        throw new Error(`Missing required environment variable: ${varName}`);
    }
});
```

### Dependency Injection

- **Inject Prisma Client**: Inject Prisma client via Express middleware
- **Avoid Global State**: Avoid global state for database connections
- **Testability**: Use dependency injection to improve testability

```typescript
// Middleware to inject Prisma client
app.use((req: Request, res: Response, next: NextFunction) => {
    req.prisma = prisma;
    next();
});

// Use in controllers
export async function getCandidate(req: Request, res: Response) {
    const candidate = await req.prisma.candidate.findUnique({
        where: { id: req.params.id }
    });
    res.json(candidate);
}
```

### Authentication & Authorization Patterns

Authentication is a critical security component in Jaarvi. The system implements JWT-based authentication with support for both email/password and OAuth providers (Google, Apple).

#### JWT Token Structure

Jaarvi uses a dual-token system with short-lived access tokens and long-lived refresh tokens:

- **Access Token**: Short-lived (15 minutes), contains user claims
- **Refresh Token**: Long-lived (7 days), stored hashed in database
- **Token Rotation**: Refresh tokens are rotated on each refresh for enhanced security

**Token Payload Structure**:

```typescript
interface JWTPayload {
  sub: string;          // User UUID
  email: string;        // User email
  iat: number;          // Issued at timestamp
  exp: number;          // Expiration timestamp
  type: 'access' | 'refresh';  // Token type
}
```

**Token Generation Example**:

```typescript
import jwt from 'jsonwebtoken';

export function generateAccessToken(user: User): string {
  return jwt.sign(
    {
      sub: user.id,
      email: user.email,
      type: 'access'
    },
    process.env.JWT_SECRET!,
    { expiresIn: process.env.JWT_ACCESS_EXPIRATION || '15m' }
  );
}

export function generateRefreshToken(user: User): string {
  return jwt.sign(
    {
      sub: user.id,
      email: user.email,
      type: 'refresh'
    },
    process.env.JWT_SECRET!,
    { expiresIn: process.env.JWT_REFRESH_EXPIRATION || '7d' }
  );
}
```

#### OAuth 2.0 Flow (Google & Apple Sign-In)

Jaarvi supports OAuth authentication for seamless user onboarding:

**OAuth Flow Steps**:

1. **Frontend initiates OAuth** with provider (Google/Apple)
2. **Provider returns authorization code** to frontend callback
3. **Frontend sends code to backend** `/api/auth/oauth/{provider}` endpoint
4. **Backend exchanges code** for provider access token
5. **Backend retrieves user profile** from provider
6. **Backend creates or links user account** in Jaarvi database
7. **Backend returns Jaarvi JWT tokens** (access + refresh)

**OAuth Implementation Example**:

```typescript
import { google } from 'googleapis';

export async function authenticateWithGoogle(code: string): Promise<AuthResponse> {
  // Exchange authorization code for tokens
  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI
  );
  
  const { tokens } = await oauth2Client.getToken(code);
  oauth2Client.setCredentials(tokens);
  
  // Get user profile from Google
  const oauth2 = google.oauth2({ version: 'v2', auth: oauth2Client });
  const { data } = await oauth2.userinfo.get();
  
  // Find or create user in Jaarvi database
  let user = await prisma.user.findUnique({
    where: { email: data.email! }
  });
  
  if (!user) {
    // Create new user
    user = await prisma.user.create({
      data: {
        email: data.email!,
        displayName: data.name || data.email!,
        emailVerifiedAt: new Date(),
        status: 'active'
      }
    });
    
    // Create OAuth account link
    await prisma.oAuthAccount.create({
      data: {
        userId: user.id,
        provider: 'google',
        providerAccountId: data.id!,
        accessTokenEncrypted: encryptToken(tokens.access_token!),
        refreshTokenEncrypted: tokens.refresh_token ? encryptToken(tokens.refresh_token) : null,
        tokenExpiresAt: tokens.expiry_date ? new Date(tokens.expiry_date) : null
      }
    });
  }
  
  // Generate Jaarvi JWT tokens
  const accessToken = generateAccessToken(user);
  const refreshToken = generateRefreshToken(user);
  
  // Store refresh token in database
  await storeRefreshToken(user.id, refreshToken);
  
  return { user, accessToken, refreshToken };
}
```

#### Session Management

Jaarvi tracks sessions to support multiple concurrent devices and enable session revocation:

- **Session Tracking**: Each login creates a `Session` record with device information
- **Multiple Sessions**: Users can be logged in on multiple devices simultaneously
- **Session Revocation**: Logout revokes the current session and associated refresh token
- **Refresh Token Rotation**: Each refresh creates a new token and marks the old one as rotated

**Session Storage Example**:

```typescript
export async function createSession(
  userId: string,
  deviceName: string,
  userAgent: string,
  ipAddress: string
): Promise<Session> {
  return await prisma.session.create({
    data: {
      userId,
      deviceName,
      userAgent,
      ipAddress,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    }
  });
}

export async function revokeSession(sessionId: string): Promise<void> {
  await prisma.session.update({
    where: { id: sessionId },
    data: { revokedAt: new Date() }
  });
  
  // Also revoke all refresh tokens for this session
  await prisma.refreshToken.updateMany({
    where: { sessionId },
    data: { revokedAt: new Date() }
  });
}
```

#### Password Security

Password security follows industry best practices:

- **Algorithm**: argon2id (recommended) or bcrypt as fallback
- **Minimum Length**: 8 characters
- **Password Reset**: Single-use tokens with 1-hour expiration
- **Rate Limiting**: Maximum 5 failed login attempts per 15 minutes per IP

**Password Hashing Example**:

```typescript
import argon2 from 'argon2';

export async function hashPassword(password: string): Promise<string> {
  return await argon2.hash(password, {
    type: argon2.argon2id,
    memoryCost: 2 ** 16,  // 64 MB
    timeCost: 3,
    parallelism: 1
  });
}

export async function verifyPassword(hash: string, password: string): Promise<boolean> {
  try {
    return await argon2.verify(hash, password);
  } catch (error) {
    return false;
  }
}
```

**Password Reset Flow**:

```typescript
export async function requestPasswordReset(email: string): Promise<void> {
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) {
    // Don't reveal if email exists (security best practice)
    return;
  }
  
  // Generate random token
  const token = crypto.randomBytes(32).toString('hex');
  const tokenHash = crypto.createHash('sha256').update(token).digest('hex');
  
  // Store hashed token
  await prisma.passwordResetToken.create({
    data: {
      userId: user.id,
      tokenHash,
      expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1 hour
    }
  });
  
  // Send email with token (implementation depends on email service)
  await sendPasswordResetEmail(user.email, token);
}

export async function resetPassword(token: string, newPassword: string): Promise<void> {
  const tokenHash = crypto.createHash('sha256').update(token).digest('hex');
  
  const resetToken = await prisma.passwordResetToken.findFirst({
    where: {
      tokenHash,
      usedAt: null,
      expiresAt: { gt: new Date() }
    },
    include: { user: true }
  });
  
  if (!resetToken) {
    throw new Error('Invalid or expired reset token');
  }
  
  // Hash new password
  const passwordHash = await hashPassword(newPassword);
  
  // Update user password
  await prisma.userCredential.update({
    where: { userId: resetToken.userId },
    data: {
      passwordHash,
      passwordAlgo: 'argon2id',
      passwordUpdatedAt: new Date()
    }
  });
  
  // Mark token as used
  await prisma.passwordResetToken.update({
    where: { id: resetToken.id },
    data: { usedAt: new Date() }
  });
  
  // Revoke all existing sessions for security
  await prisma.session.updateMany({
    where: { userId: resetToken.userId },
    data: { revokedAt: new Date() }
  });
}
```

#### API Authentication Middleware

All protected routes require JWT validation via middleware:

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
  };
}

export async function authenticateJWT(
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ message: 'Missing or invalid authorization header' });
    return;
  }
  
  const token = authHeader.substring(7); // Remove 'Bearer ' prefix
  
  try {
    // Verify token
    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;
    
    // Verify token type
    if (payload.type !== 'access') {
      res.status(401).json({ message: 'Invalid token type' });
      return;
    }
    
    // Verify user exists and is active
    const user = await prisma.user.findUnique({
      where: { id: payload.sub }
    });
    
    if (!user || user.status !== 'active') {
      res.status(401).json({ message: 'User not found or inactive' });
      return;
    }
    
    // Attach user to request
    req.user = {
      id: user.id,
      email: user.email
    };
    
    next();
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      res.status(401).json({ message: 'Token expired' });
    } else if (error instanceof jwt.JsonWebTokenError) {
      res.status(401).json({ message: 'Invalid token' });
    } else {
      res.status(500).json({ message: 'Authentication error' });
    }
  }
}

// Apply to all /api routes
app.use('/api', authenticateJWT);

// Exclude authentication routes
app.use('/api/auth', authRoutes); // This should be registered before authenticateJWT middleware
```

#### Rate Limiting

Implement rate limiting to prevent brute-force attacks:

```typescript
import rateLimit from 'express-rate-limit';

// Login rate limiter: 5 attempts per 15 minutes
export const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5,
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply to login route
app.post('/api/auth/login', loginLimiter, loginController);

// General API rate limiter: 100 requests per 15 minutes
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply to all API routes
app.use('/api', apiLimiter);
```

### Environment Configuration

Proper environment configuration is critical for security and deployment flexibility.

#### Required Environment Variables

**Development Environment (.env.example)**:

```bash
# ========================================
# Database Configuration
# ========================================
DATABASE_URL="postgresql://jaarvi_dev:jaarvi_local_dev_2024@localhost:5432/jaarvi_dev"

# ========================================
# Server Configuration
# ========================================
NODE_ENV=development
PORT=3000

# ========================================
# Authentication Configuration
# ========================================
JWT_SECRET="development-secret-min-32-chars-change-in-production"
JWT_ACCESS_EXPIRATION=15m
JWT_REFRESH_EXPIRATION=7d

# ========================================
# OAuth Providers
# ========================================
GOOGLE_CLIENT_ID="your-google-client-id.apps.googleusercontent.com"
GOOGLE_CLIENT_SECRET="your-google-client-secret"
GOOGLE_REDIRECT_URI="http://localhost:3000/api/auth/oauth/google/callback"

APPLE_CLIENT_ID="your.app.bundle.id"
APPLE_TEAM_ID="your-apple-team-id"
APPLE_KEY_ID="your-apple-key-id"
APPLE_PRIVATE_KEY_PATH="./certs/AuthKey_XXXXX.p8"

# ========================================
# CORS Configuration
# ========================================
FRONTEND_URL=http://localhost:3001
ALLOWED_ORIGINS=http://localhost:3001,http://localhost:19006,http://10.0.2.2:3000

# ========================================
# AWS Services (Phase 2)
# ========================================
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your-access-key-id
AWS_SECRET_ACCESS_KEY=your-secret-access-key
AWS_S3_BUCKET_DOCUMENTS=jaarvi-documents-dev
AWS_BEDROCK_MODEL=anthropic.claude-v2  # Phase 2 only

# ========================================
# Logging Configuration
# ========================================
LOG_LEVEL=debug

# ========================================
# Email Service (for password reset)
# ========================================
EMAIL_SERVICE=smtp
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=noreply@jaarvi.app
EMAIL_PASSWORD=your-email-password
EMAIL_FROM=Jaarvi <noreply@jaarvi.app>
```

**Production Requirements**:

- **Secrets Management**: Use AWS Secrets Manager or Parameter Store
- **Secret Rotation**: Rotate JWT_SECRET every 90 days
- **Logging**: Never log secrets, tokens, or passwords
- **Environment Isolation**: Use different secrets per environment (dev/staging/prod)
- **Encryption**: Store OAuth tokens encrypted in database

#### Secret Validation on Startup

Validate required environment variables at application startup to fail fast:

```typescript
// src/infrastructure/env.ts

interface RequiredEnvVars {
  DATABASE_URL: string;
  JWT_SECRET: string;
  JWT_ACCESS_EXPIRATION: string;
  JWT_REFRESH_EXPIRATION: string;
  FRONTEND_URL: string;
  ALLOWED_ORIGINS: string;
  NODE_ENV: 'development' | 'staging' | 'production';
  PORT: string;
}

export function validateEnvironment(): void {
  const requiredVars: (keyof RequiredEnvVars)[] = [
    'DATABASE_URL',
    'JWT_SECRET',
    'FRONTEND_URL',
    'ALLOWED_ORIGINS'
  ];
  
  const missingVars: string[] = [];
  
  for (const varName of requiredVars) {
    if (!process.env[varName]) {
      missingVars.push(varName);
    }
  }
  
  if (missingVars.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missingVars.join(', ')}`
    );
  }
  
  // Validate JWT_SECRET length
  if (process.env.JWT_SECRET!.length < 32) {
    throw new Error('JWT_SECRET must be at least 32 characters');
  }
  
  // Validate NODE_ENV
  const validEnvs = ['development', 'staging', 'production'];
  if (process.env.NODE_ENV && !validEnvs.includes(process.env.NODE_ENV)) {
    throw new Error(`NODE_ENV must be one of: ${validEnvs.join(', ')}`);
  }
  
  console.log('âœ… Environment variables validated successfully');
}

// Call at application startup (src/index.ts)
import { validateEnvironment } from './infrastructure/env';

validateEnvironment();
```

#### Accessing Environment Variables

Create typed accessors for environment variables:

```typescript
// src/infrastructure/config.ts

export const config = {
  database: {
    url: process.env.DATABASE_URL!
  },
  server: {
    port: parseInt(process.env.PORT || '3000', 10),
    nodeEnv: process.env.NODE_ENV || 'development'
  },
  auth: {
    jwtSecret: process.env.JWT_SECRET!,
    accessTokenExpiration: process.env.JWT_ACCESS_EXPIRATION || '15m',
    refreshTokenExpiration: process.env.JWT_REFRESH_EXPIRATION || '7d'
  },
  oauth: {
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      redirectUri: process.env.GOOGLE_REDIRECT_URI
    },
    apple: {
      clientId: process.env.APPLE_CLIENT_ID,
      teamId: process.env.APPLE_TEAM_ID,
      keyId: process.env.APPLE_KEY_ID,
      privateKeyPath: process.env.APPLE_PRIVATE_KEY_PATH
    }
  },
  cors: {
    frontendUrl: process.env.FRONTEND_URL!,
    allowedOrigins: process.env.ALLOWED_ORIGINS!.split(',')
  },
  aws: {
    region: process.env.AWS_REGION || 'us-east-1',
    s3: {
      documentsBucket: process.env.AWS_S3_BUCKET_DOCUMENTS
    },
    bedrock: {
      model: process.env.AWS_BEDROCK_MODEL // Phase 2 only
    }
  },
  logging: {
    level: process.env.LOG_LEVEL || 'info'
  }
} as const;
```

## Development Workflow

### Git Workflow

- **Feature Branches**: Develop features in separate branches, adding descriptive suffix "-backend" to allow working in parallel and avoid conflicts or collisions
- **Descriptive Commits**: Write descriptive commit messages in English
- **Code Review**: Code review before merging
- **Small Branches**: Keep branches small and focused

### Development Scripts

```bash
npm run dev          # Development server with hot reload
npm run build        # Build for production
npm test             # Run tests
npm run test:coverage # Run tests with coverage
npm run prisma:generate  # Generate Prisma client
npx prisma migrate dev   # Create and apply migration
npx prisma db seed       # Seed database
```

### Code Quality

- **ESLint Validation**: Run ESLint before commits
- **TypeScript Compilation**: Ensure TypeScript compiles without errors
- **All Tests Passing**: Ensure all tests pass before deployment
- **Code Review**: Review code for adherence to standards

## Serverless Deployment

### AWS Lambda Configuration

- **Lambda Handler**: Entry point is `src/lambda.ts`
- **Serverless HTTP**: Use `serverless-http` to wrap Express app
- **Environment Variables**: Configure environment variables in `serverless.yml`

### Serverless Framework

- **Configuration File**: `serverless.yml` defines Lambda configuration
- **Build Command**: Use `npm run build:lambda` for Lambda builds
- **Deployment**: Deploy using Serverless Framework CLI

```typescript
// lambda.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import serverless from 'serverless-http';
import { app } from './index';

const serverlessHandler = serverless(app);

export const handler = async (
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> => {
  context.callbackWaitsForEmptyEventLoop = false;
  return await serverlessHandler(event, context) as APIGatewayProxyResult;
};
```

This document serves as the foundation for maintaining code quality and consistency across the LTI backend application. All team members should follow these practices to ensure a maintainable, scalable, and testable codebase.
